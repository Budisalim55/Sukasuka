var prompt      = require('prompt'),
    _resource    = require('resource'),
    colors      = require('colors'),
    cliff       = require('cliff'),
    controller  = require('./command/controller')
    logger      = require('./command/logger'),
    argv        = require('optimist').argv;

//
// Set up prompt overrides with optimist.argv (default)
//
prompt.override = argv;

//
// Miniature cli router that actually works ( feel free to replace )
//
var router = {
  _routes: {
  },
  route: function (_command) {

    //
    // Use either the supplied command, or the command from argv
    //
    _command = _command ||  argv._.join(' ');

    var routes = this._routes,
        part,
        c = _command.split(' ');

    //
    // If there is no match for the command, assume its because additional arguments,
    // have been supplied after the command and use those additional arguments as method arguments
    //
    // Ex:
    //
    //    big creature create bobby
    //
    //  will not be found, and instead attempt
    //
    //    big creature create
    //    controller.create("bobby")
    //
    if(typeof routes[_command] !== 'function') {
      part = c[c.length - 1];
      c.pop();
    }
    //
    // Join the command array back into a string
    //
    c = c.join(' ');

    //
    // If the command is a function, execute it
    //
    if(typeof routes[c] === 'function') {
      routes[c](part);
    } else {
      //
      // If not, we have a missing method
      //
      logger.error('resource ' + c.magenta +  ' not found')
    }
  },

  //
  // binds a command a function to the routing table
  //
  on: function (_command, fn){
    this._routes[_command] = fn;
  }

}

exports.createRouter = function (resources, options) {

  options = options || {};

  if(typeof resources === 'object' && !Array.isArray(resources)) {
    var arr = []
    for (var r in resources) {
      arr.push(resources[r]);
    }
    resources = arr;
   }

  router.on("", function(){
    logger.info('resources'.magenta + ' available:');
    resources.forEach(function (resource) {
      logger.info(' - ' + resource.name.magenta + ' ' + (resource.schema.description || '').grey);
    });
    logger.help('type ' + 'the ' + 'resource'.magenta + ' name to use');
  });
  
  resources.forEach(function (resource) {
    var entity = resource.name
        param = options.param || ':id';
    //
    // Route for resource name itself.
    // Shows help / additional instructions for next level of commands
    //
    router.on(entity, function() {
      if (typeof resource.schema.description !== 'undefined') {
        logger.help(resource.schema.description)
      }

      //
      // The root level of a resource,
      // show all immediate child commands
      //
      logger.info(resource.name.magenta + ' methods:')
      for (var m in resource.methods) {
        if(typeof resource.methods[m] === "function") {
          var self = this,
              desc = '';
          if(typeof resource.methods[m].schema !== 'undefined' && resource.methods[m].schema.description !== 'undefined') {
            desc = resource.methods[m].schema.description || '';
          }
          logger.info(' - ' + m.magenta + ' ' + desc.grey );
        }
      }
      logger.help('type the ' + 'method'.magenta + ' name');
    });

    //
    // Find every function on the resource,
    // which has the "remote" property set to "true"
    //
    for (var m in resource.methods) {
      //console.log(resource.methods[mappings[m]], m)
      var _method = resource.methods[m];
      if(typeof _method === "function") {
        var self = this;
        //
        // Must maintain scope of m in callback closure
        //
        (function(m){
          router.on(entity + ' ' + m, function(_id){
            var defaults = {},
                _args    = [];
            if(typeof controller[m] === 'function') {
              controller[m](_id, {}, resource);
            } else {
              controller.resourceMethod(_id, m, resource);
            }
          });
        })(m);
      }
    }
  });

  return router;

};


function promptToList (resource, callback) {
  var property = {
    name: 'yesno',
    message: 'list all ' + (resource.name + 's') + '?', // TODO: Fix inflection
    validator: /y[es]*|n[o]?/,
    warning: 'Must respond yes or no',
    default: 'yes'
  };
  prompt.get(property, function(err, result){
    if (err || result.yesno !== "yes") {
      logger.warn('action cancelled')
      return;
    }
    callback(null, result);
  });
}

exports.route = router.route;
