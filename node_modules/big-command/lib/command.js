var prompt      = require('prompt'),
    _resource    = require('resource'),
    colors      = require('colors'),
    cliff       = require('cliff'),
    controller  = require('./command/controller')
    logger      = require('./command/defaultLogger'),
    utile       = require('utile'),
    argv        = require('optimist').argv;

//
// Set up prompt overrides with optimist.argv (default)
//
prompt.override = argv;


//
// Miniature cli router ( feel free to replace )
//
var router = {
  _routes: {
  },
  route: function (_command) {
    _command = _command ||  argv._.join(' ');
    var routes = this._routes;
    var part;
    var c = _command.split(' ');
    if(typeof routes[_command] === 'undefined') {
      part = c[c.length - 1];
      c.pop();
      //console.log('couldnt find', _command, 'maybe', c);
    }
    c = c.join(' ');
    //console.log('firing', c, part);
    routes[c](part);
  },
  on: function (_command, fn){
    this._routes[_command] = fn;
  }
}

exports.createRouter = function (resources, options) {

  options = options || {};

  if(typeof resources === 'object' && !Array.isArray(resources)) {
    var arr = []
    for (var r in resources) {
      arr.push(resources[r]);
    }
    resources = arr;
   }

  router.on("", function(){
    logger.info('the following resources are available');
    resources.forEach(function (resource) {
      logger.info(' - ' + resource.name.magenta)
    });
  });
  
  router.on('help', function(){
    logger.info('the following resources are available');
    resources.forEach(function (resource) {
      logger.info(' - ' + resource.name.magenta)
    })
  })

  resources.forEach(function (resource) {
    var entity = resource.name
        param = options.param || ':id';
    //
    // Route for resource name itself.
    // Shows help / additional instructions for next level of commands
    //
    router.on(entity, function() {
      //
      // The root level of a resource,
      // show all immediate child commands
      //
      logger.info(resource.name.magenta + ' has the following methods:')
      for (var m in resource.methods) {
        if(typeof resource.methods[m] === "function") {
          var self = this;
          logger.info(' - ' + m.magenta)
        }
      }
    });

    //
    // Find every function on the resource,
    // which has the "remote" property set to "true"
    //
    for (var m in resource.methods) {
      //console.log(resource.methods[mappings[m]], m)
      var _method = resource.methods[m];
      if(typeof _method === "function") {
        var self = this;

        //
        // Must maintain scope of m in callback closure
        //
        (function(m){
          router.on(entity + ' ' + m, function(_id){
            var defaults = {},
                _args    = [];
            if(typeof controller[m] === 'function') {
              controller[m](_id, {}, resource);
            } else {
              controller.resourceMethod(_id, m, resource);
            }
          });
        })(m);
        /*
        router.on(entity + ' ' + m + ' :id', function(_id) {
          controller.resourceMethod(_id, m, resource);
        });
        */
      }
    }
  });

  return router;

};


function promptToList (resource, callback) {
  var property = {
    name: 'yesno',
    message: 'list all ' + (resource.name + 's') + '?', // TODO: Fix inflection
    validator: /y[es]*|n[o]?/,
    warning: 'Must respond yes or no',
    default: 'yes'
  };
  prompt.get(property, function(err, result){
    if (err || result.yesno !== "yes") {
      logger.warn('action cancelled')
      return;
    }
    callback(null, result);
  });
}

exports.route = router.route;
