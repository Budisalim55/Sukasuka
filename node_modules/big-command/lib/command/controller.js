var controller = exports;

var cliff  = require('cliff'),
    prompt = require('prompt');

//
// Maps to Resource.get
//
controller.get = function (id, data, resource) {
  if (typeof id !== 'undefined') {
    resource.get(id, function(err, result){
      if(err) {
        logger.error(JSON.stringify(err))
        return;
      }
      logger.info('showing ' + id.magenta);
      cliff.putObject(result);
    });
  } else {
    logger.error('id is required to get');
  }
}

//
// Maps to Resource.all
//
controller.all = function (id, options, resource) {
  logger.info('showing all ' + resource.name.magenta);
  resource.all(function(err, rows){
    if(err) {
      logger.error(JSON.stringify(err))
      return;
    }
    if (rows.length === 0) {
      logger.info('no ' + resource.name.magenta + ' found')
    } else {
      var lines = cliff.stringifyObjectRows(rows, Object.keys(resource.schema.properties), ['underline'], { columnSpacing: 5 }).split('\n');
      lines.forEach(function(line){
        logger.info(line);
      })
    }
  })
};

//
// Maps to Resource.create
//
controller.create = function (id, data, resource) {
  logger.warn('prompting user for data');
  if(typeof prompt.override.id !== 'undefined') {
    logger.info('define ' + prompt.override.id.magenta);
  } else {
    logger.info('define new ' + resource.name.magenta);
  }
  prompt.get(resource.schema, function (err, result) {
    if(err) {
      return;
    }
    logger.info('about to create ' + resource.name.magenta);
    cliff.putObject(result);
    resource.create(result, function(err, r){
      if(err) {
        logger.error(JSON.stringify(err))
        return;
      }
      logger.info('created new ' + resource.name.magenta + ' ' + r.id.grey)
    })
  });
};

//
// Maps to Resource.update
//
controller.update = function (id, data, resource) {

  if (typeof id !== 'undefined') {
    resource.get(id, function(err, record) {
      if(err) {
        logger.error(JSON.stringify(err))
        return;
      }

      var _schema = resource.methods.update.schema;

      Object.keys(_schema.properties.options.properties).forEach(function(prop){
        _schema.properties.options.properties[prop].default = record[prop];
      });

      logger.info('updating ' + resource.name.magenta + ' ' + record.id);
      logger.warn('prompting user for data');
      prompt.get(_schema.properties.options, function (err, result) {
        if(err) {
          return;
        }
        logger.info('about to save ' + resource.name.magenta);
        cliff.putObject(result);
        result.id = record.id;
        confirm(function(err, promptResult){
          resource.update(result, function(err, r){
            if(err) {
              return logger.error(JSON.stringify(err))
            }
            logger.info('saved ' + resource.name.magenta + ' ' + r.id.grey)
          })
        });
      });
    });
  } else {
    // TODO: prompt for id
    logger.error('id is required to get');
  }

};

//
// Maps to Resource.destroy
//
controller.destroy = function (id, resource) {
  resource.get(id, function(err, record){
    if(err) {
      logger.error(JSON.stringify(err))
      return;
    }
    var schema = utile.clone(resource.schema);
    logger.info('about to destroy ' + resource.name.magenta + ' ' + record.id);
    cliff.putObject(record);
    confirm(function(err, promptResult){
      resource.destroy(record.id, function(err, r){
        if(err) {
          logger.error(JSON.stringify(err))
          return;
        }
        logger.info('destroyed' + ' ' + r.id.magenta)
      });
    });
  });
};

//
// Maps to Resource.methods[method]
//
controller.resourceMethod = function (id, method, resource) {

  var _args = [];

  logger.info('executing resource method ' + method.magenta);

  //
  // If there is a supplied schema for this resource method,
  // then prompt the user to fill out the schema
  //

  if(typeof resource[method].schema === 'object' && typeof resource[method].schema.properties === 'object') {

    var _schema = resource[method].schema;
    //
    // Check to see if the convention of an options / callback is used,
    // if not, just use the schema as is
    //
    _schema = _schema.properties.options || _schema;
    prompt.get(_schema, function(err, result){
      if(err) {
        logger.error(JSON.stringify(err));
        return;
      }

      var arr = [];

      //
      // If the method schema contains an options hash,
      // push the result as an object
      //
      if(typeof _schema.properties.options === 'object') {
        arr.push(result);
      } else {
        //
        // If the method schema is not using an options hash,
        // push each result as a new array argument
        //
        Object.keys(_schema.properties).forEach(function(prop){
          arr.push(result[prop]);
        });
      }

      //
      // Create a continuation for the resource method call
      //
      var fn = function(err, _result){
        if(err) {
          logger.error(JSON.stringify(err));
          return;
        }
        logger.info('executed ' + method.magenta)
        logger.data(_result);
      };

      if (typeof _schema.properties.callback === 'object') {
        //
        // If the method schema contains a callback,
        // push the continuation
        //
        arr.push(fn);
        return resource[method].apply([], arr);
      } else {
        //
        // The method schema has no callback,
        // execute the continuation now
        //
        return fn(null, resource[method].apply([], arr));
      }

    });
  } else {
    //
    // If no schema was provided for the method,
    // assume that its returning a value, and not using a callback...
    //
    var result = resource[method]();
    logger.info('executed ' + method.magenta);
    cliff.putObject(result);
  }

};

function confirm (callback) {
  var property = {
    name: 'yesno',
    message: 'are you sure?',
    validator: /y[es]*|n[o]?/,
    warning: 'Must respond yes or no',
    default: 'yes'
  };
  prompt.get(property, function(err, result){
    if (err || result.yesno !== "yes") {
      logger.warn('action cancelled')
      return;
    }
    callback(null, result);
  });
}
